# 라즈베리파이에 프로젝트 배포하기

## 라즈베리파이에 Docker로 Next.js 블로그 배포하기

1. SSH를 통한 라즈베리파이 원격접속

   OS 전체 정보 확인

   ```bash
   cat /etc/os-realease
   ```

   ![image-20250408151727703](/Users/edgar/Documents/TILv2/라즈베리파이 배포.assets/image-20250408151727703.png)

   `~` : 현재 로그인한 사용자의 홈 디렉토리

   `/` : 리눅스 시스템의 루트 디렉토리

2. Docker & Docker Compose 설치

   ```bash
   sudo apt update # 패키지 목록 최신화
   sudo apt install -y docker.io # Docker 설치
   sudo apt install -y docker-compose # Docker Compose 설치
   sudo reboot # 재부팅(선택)
   ```

   ![image-20250408151602458](/Users/edgar/Documents/TILv2/라즈베리파이 배포.assets/image-20250408151602458.png)

   ![image-20250408153147059](/Users/edgar/Documents/TILv2/라즈베리파이 배포.assets/image-20250408153147059.png)

   ![image-20250408153419404](/Users/edgar/Documents/TILv2/라즈베리파이 배포.assets/image-20250408153419404.png)

   ```bash
   docker -v # Docker version 20.10.24+dfsg1, build 297e128
   docker-compose -v # docker-compose version 1.29.2, build unknown
   ```

3. 블로그 프로젝트 Docker로 띄우기

   github에서 클론하는 경우 :

   ```bash
   git clone https://github.com/your-username/your-repo-name.git # GitHub에서 프로젝트 클론
   cd your-repo-name # 프로젝트 디렉토리로 이동
   ```

   로컬에서 복사하는 경우(맥북 터미널에서) :

   ```bash
   scp -r ./your-blog-folder pi@raspberrypi.local:~/your-blog-folder   # 프로젝트를 라즈베리파이로 복사
   ```

   그리고 라즈베리파이에서

   ```bash
   cd ~/your-blog-folder
   ```

4. .env 파일 생성

   ```bash
   nano .env # 환경변수 파일 생성
   ```

   ```bash
   DATABASE_URL=postgresql://bloguser:yourpassword@db:5432/blogdb   # PostgreSQL 접속 정보 (docker-compose의 db 서비스 기준)
   NEXT_PUBLIC_BASE_URL=http://your.rpi.ip.address:3000             # 라즈베리파이의 IP 주소
   ```

   > 저장 : Ctrl + O, 종료 : Ctrl + X

5. Docker-compose.yml 생성

   여러 개의 Docker 컨테이너를 한번에 쉽게 정의하고 실행하기 위함

   현재 블로그 프로젝트는 Next.js, PostgresSQL DB 이렇게 두 개의 컨테이너가 필요한데 docker-compose 없이 하려면 아래와 같은 방식으로 컨테이너 실행 및 Dockerfile 빌드를 따로 해줘야함

   ```bash
   # PostgreSQL 컨테이너 따로 실행
   docker run -d \
     --name my-db \
     -e POSTGRES_USER=bloguser \
     -e POSTGRES_PASSWORD=yourpassword \
     -e POSTGRES_DB=blogdb \
     postgres:15
   
   # Next.js 앱 Dockerfile 빌드
   docker build -t my-blog-app .
   
   # Next.js 컨테이너 실행
   docker run -d \
     --name my-app \
     --env-file .env \
     -p 3000:3000 \
     --link my-db \
     my-blog-app
   ```

   docker-compose를 사용하면, docker-compose.yml 파일 하나로 

   - 어떤 컨테이너를 몇 개 띄울지
   - 환경변수, 포트, 볼륨, 의존성
   - 실행 순서, 이름까지

   다 한 파일에 정리할 수 있다.

   현재 돌아가는 컨테이너 목록 확인

   ```bash
   docker ps -a
   ```

6. Dockerfile 생성

   Docker가 앱을 컨테이너로 만들려면 빌드 방법이 필요

   Node 설치, 코드 복사, 빌드, 실행 이러한 흐름만 있으면 됨

   ```dockerfile
   # Node.js LTS 기반 이미지 사용 (ARM에서도 잘 돌아감)
   FROM node:18
   # 작업 디렉토리 설정
   WORKDIR /app
   # 코드 복사
   COPY . .
   # 의존성 설치
   RUN npm install
   
   # Next.js 앱 빌드
   RUN npm run build
   
   # 3000 포트 노출
   EXPOSE 3000
   
   # 앱 실행 (빌드된 Next 앱 실행)
   CMD ["npm", "start"]
   ```

   준비됐으면 실행(정의된 서비스를 백그라운드로 빌드하고 실행)

   ```bash
   docker-compose up -d
   ```

7. Prisma 마이그레이션(초기 1회)

   ```bash
   docker-compose exec blog npx prisma migrate deploy
   ```

   blog는 Next.js 앱 서비스 이름 기준. 서비스명이 다르면 docker-compose ps로 컨테이너 이름 확인하고 맞추면 됨

8. 컨테이너 실행

9. 정상동작 확인

   ```bash
   docker ps
   docker ps -a
   ```

## 외부 접속 설정하기

### 1. 라즈베리파이 공인 IP 확인 & 포트 포워딩 설정

- 먼저, 라즈베리파이가 인터넷을 통해 접근 가능한 IP 주소를 가져야한다. 현재 집에서 사용하는 대부분의 인터넷은 공유기 뒤에 있는 사설 IP만 갖고 있으니 이를 위해 포트 포워딩이 필요하다.

  :bulb: 포트포워딩? 포트포워딩 개념은 집에서 사용하는 공유기는 하나의 공인 IP로 여러 기기를 연결시키기 때문에, 외부에서 들어오는 요청이 어느 기기로 가야하는지 알 수 없다. 그래서 "이 포트로 요청이 들어오면 이 내부 기기로 보내줘!"하고 공유기한테 미리 알려주는 설정이 포트포워딩이다.

  예시 : 라즈베리파이 내부 IP가 `192.168.0.101` 이고, 블로그가 3000번 포트에서 실행중일 때 공유기 포트 포워딩에 아래처럼 설정하면 **외부 요청을 내부 장비로 전달하는 터널 같은 역할**을 해준다

  ```
  외부에서 http://공인IP:80 으로 요청 →
  공유기가 192.168.0.101:3000으로 전달 →
  라즈베리파이의 블로그 서비스 응답
  ```

- 라즈베리파이에서 브라우저나 터미널로 `https://ifconfig.me` 접속하여 라즈베리파이의 공인 IP 주소를 확인한다.

  ```bash
  curl https://ifconfig.me
  # 211.49.195.42
  ```

  :bulb: 공인 IP 주소는 공유기 바깥 즉, 인터넷에 연결된 모든 사람(외부)에게 보이는 IP 주소를 말하는데 공유기 하나가 이걸 가지고 있다. 위에서 말한 사설 IP는 공유기에 연결된 각 기기(맥북, 라즈베리파이 등)가 내부에서만 사용하는 IP 주소를 말한다. 예: `192.168.x.x`

  예를들어 공인 IP가 `123.45.67.89`라면 외부에서 블로그에 접속하기 위해 `123.45.67.89`로 요청을 보내야한다.

  하지만 우리가 사용중인 라즈베리파이가 직접 공인 IP를 가진 게 아니기 때문에, 공유기가 그 요청을 라즈베리파이에게 **포트 포워딩**으로 전달해줘야 한다.

- 공유기 관리자 페이지에 접속하여 포트 포워딩 설정

  페이지 접속 후 보통의 경로 : **고급 설정** → **NAT/라우터 설정** → **포트 포워딩**

  설정정보

  | **항목**        | **입력값**    | **설명**                |
  | --------------- | ------------- | ----------------------- |
  | 포트포워드 활성 | ✅ 체크        | 반드시 체크해야 동작해  |
  | 외부 포트 범위  | 3000 - 3000   | 외부에서 열 포트        |
  | 내부 IP 주소    | 192.168.0.101 | 라즈베리파이의 IP       |
  | 내부 포트       | 3000          | 블로그가 동작하는 포트  |
  | 프로토콜        | TCP 또는 BOTH | TCP만 해도 충분         |
  | 설명            | nextjs-blog   | 네가 알아보기 위한 이름 |

### 2. 가비아 도메인에 A레코드 설정

✅ A레코드로 **도메인을 공인 IP에 연결**

- 가비아 A레코드 설정

  | **항목** | **설정값**                |
  | -------- | ------------------------- |
  | 타입     | A                         |
  | 호스트   | @                         |
  | 값/위치  | 너의 공인 IP 주소         |
  | TTL      | 그대로 두면 됨 (예: 1800) |

- 호스트가 @인 경우

  edgar-kim.com 루트 도메인을 의미함. 즉, http://edgar-kim.com 으로 접속 가능하게 됨

- TTL(Time To Live)

  TTL은 DNS 레코드가 얼마나 오래 "캐시(저장)"되어야 하는지를 나타내는 시간 값. 즉, 사용자의 컴퓨터나 DNS 서버가 이 정보를 "몇 초 동안 기억할지"를 정하는 값

  예를들어 TTL을 1800으로 설정 후 어떤 사용자가 한 번 접속하면 그 사람의 컴퓨터나 중간 DNS 서버는 이 IP 정보를 1800초(=30분) 동안 기억한다. 이 30분 동안은 DNS 서버에 다시 물어보지 않고 캐시된 IP로 접속한다.

- TTL 설정 팁은 처음 도메인 연결하거나 테스트 중일 경우엔 짧게(예 : 300), 설정이 안정화된 운영 환경에선 길게(예: 3600, 86400 등)

### 3. Next.js 앱을 Nginx로 reverse proxy 세팅(선택)

**전체 흐름 요약**

1. Nginx 설치 및 설정 (80 → 3000 리버스 프록시)
2. Certbot 설치 및 HTTPS 인증서 발급
3. 자동 HTTPS 적용 + 리디렉션(optional)

- Nginx 설치

  ```bash
  sudo apt update
  sudo apt install nginx
  ```

  설치 후 실행 확인:

  ```bash
  sudo systemctl status nginx
  ```

- 리버스 프록시 설정(포트 80 => Docker의 3000 포트)

  ```bash
  sudo nano /etc/nginx/sites-available/edgar-kim
  ```

  아래처럼 입력

  ```bash
  server {
      listen 80;
      server_name edgar-kim.com www.edgar-kim.com;
  
      location / {
          proxy_pass http://localhost:3000;
          proxy_http_version 1.1;
          proxy_set_header Upgrade $http_upgrade;
          proxy_set_header Connection 'upgrade';
          proxy_set_header Host $host;
          proxy_cache_bypass $http_upgrade;
      }
  }
  ```

  설정 활성화 :

  ```bash
  sudo ln -s /etc/nginx/sites-available/edgar-kim /etc/nginx/sites-enabled/
  sudo nginx -t         # 설정 검사
  sudo systemctl reload nginx
  ```

  - `sudo ln -s /etc/nginx/sites-available/edgar-kim /etc/nginx/sites-enabled/` 

    > sites-available/edgar-kim 이라는 설정 파일을 sites-enabled/ 안에 연결해서 **Nginx가 실제로 이 설정을 사용하게 만드는 것**

    `ln` : **링크(Link) 생성** 명령어 (파일 시스템 상의 “바로가기”)

    `-s` : **심볼릭 링크(symbolic link)**, 윈도우로 치면 “바로가기” 같은 개념

  - `sudo nginx -t`

    **Nginx 설정 파일의 문법을 검사**하는 명령어

    설정을 바꾸고 나서 **적용하기 전에 문법 체크**할 때 꼭 써야함. 실서버에선 안 쓰고 reload 하면 서버 죽는 경우도 있음 😅

  - `sudo systemctl reload nginx`

    `systemctl` : 시스템 서비스(데몬)를 관리하는 명령어

    `reload nginx` : 설정을 다시 읽어서 **재시작 없이 적용**(restart는 서버를 껐다 켜는 거고, reload는 **중단 없이 설정만 다시 적용**하는 것이라서 웹 요청이 끊기지 않는다.)

- Certbot 설치 및 HTTPS 인증서 발급

  ```bash
  sudo apt install certbot python3-certbot-nginx
  ```

  그 다음 실행 :

  ```bash
  sudo certbot --nginx -d edgar-kim.com -d www.edgar-kim.com
  ```

  → 중간에 이메일 입력, 약관 동의 등 물어볼 수 있어

  → 자동으로 SSL 인증서 설치 + HTTPS 리디렉션 설정됨

  ![image-20250409140618641](/Users/edgar/Documents/TILv2/라즈베리파이 배포.assets/image-20250409140618641.png)

  ```bash
  sudo certbot --nginx -d edgar-kim.com -d www.edgar-kim.com
  Saving debug log to /var/log/letsencrypt/letsencrypt.log
  Requesting a certificate for edgar-kim.com and www.edgar-kim.com
  
  Successfully received certificate.
  Certificate is saved at: /etc/letsencrypt/live/edgar-kim.com/fullchain.pem
  Key is saved at:         /etc/letsencrypt/live/edgar-kim.com/privkey.pem
  This certificate expires on 2025-07-08.
  These files will be updated when the certificate renews.
  Certbot has set up a scheduled task to automatically renew this certificate in the background.
  
  Deploying certificate
  Successfully deployed certificate for edgar-kim.com to /etc/nginx/sites-enabled/edgar-kim.com
  Successfully deployed certificate for www.edgar-kim.com to /etc/nginx/sites-enabled/edgar-kim.com
  Congratulations! You have successfully enabled HTTPS on https://edgar-kim.com and https://www.edgar-kim.com
  
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  If you like Certbot, please consider supporting our work by:
   * Donating to ISRG / Let's Encrypt:   https://letsencrypt.org/donate
   * Donating to EFF:                    https://eff.org/donate-le
  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  ```

  HTTPS 인증서 발급 완료 + Nginx에 자동 적용 성공

- 테스트

  - https://edgar-kim.com 접속!

  - 크롬에서도 보안 연결로 접속 가능해야 해 🔒

- 인증서 자동 갱신 설정 확인

  ```bash
  sudo systemctl list-timers | grep certbot
  ```

  → 기본적으로 매일 갱신 여부 체크함

## Trouble Shooting :dart:

### Git Clone Error

- 깃헙에서 프로젝트 클론시 아래와 같은 에러 발생

  ```bash
  git clone https://github.com/edkim3275/edkim-blog.git
  Cloning into 'edkim-blog'...
  Username for 'https://github.com': edkim3275
  Password for 'https://edkim3275@github.com':
  remote: Support for password authentication was removed on August 13, 2021.
  remote: Please see https://docs.github.com/get-started/getting-started-with-git/about-remote-repositories#cloning-with-https-urls for information on currently recommended modes of authentication.
  fatal: Authentication failed for 'https://github.com/edkim3275/edkim-blog.git/'
  ```

  ![image-20250408161354573](/Users/edgar/Documents/TILv2/라즈베리파이 배포.assets/image-20250408161354573.png)

- 원인은 2021년부터 HTTP 방식에서 "아이디 + 비밀번호 로그인"을 막음

  따라서 Personal Access Token(PAT) 방식이나 SSH 방식 중 하나를 써야 함.

- GitHub에서 Personal Access Token(PAT)을 만든 후 해당 토큰 정보는 안전하게 보관

  https://github.com/settings/personal-access-tokens

- 라즈베리파이에 Git credential helper 설정

  라즈베리파이에 자격증명 캐시 기능 설정(메모리 기반 캐시)

  ```bash
  git config --global credential.helper cache
  git config --global credential.helper 'cache --timeout=3600'   # 1시간 저장
  ```

  | **방식**                      | **설명**                 | **보안** | **추천도**  |
  | ----------------------------- | ------------------------ | -------- | ----------- |
  | credential.helper store       | 자격증명을 평문으로 저장 | 🔸 낮음   | 간편하긴 함 |
  | credential.helper cache       | 메모리에 일정 시간 저장  | 🔹 중간   | 🔥 추천      |
  | credential.helper osxkeychain | macOS 전용               | 🔐 높음   | 맥북 전용   |

  평문 텍스트로 저장하는 방식(단순하지만 위험할 수 있어서 위의 캐시방식 권장)

  ```bash
  git config --global credential.helper store
  ```

- 한 번만 사용자 명 + PAT 입력

- 이후 자동으로 저장된 자격증명 사용됨

### Docker compose up

- `.env`, `Dockerfile`, `docker-compose.yml`생성 후 백그라운드 실행을 위해 `docker-compose up -d`를 했지만 아래와 같은 에러 발생

- PermissionError: [Errno 13] Permission denied
  docker.errors.DockerException: Error while fetching server API version

- 원인은 현재 사용자(edgar)가 docker 명령어를 실행할 권한이 없어서 생긴 에러. 즉, Docker 데몬에 접근 권한이 없는 상태.

- 방법1. sudo 붙이기(간단)

  ```bash
  sudo docker-compose up -d
  ```

  이러면 root 권한으로 Docker에 접근해서 문제 없이 실행됨.

- 방법2. docker 그룹에 현재 사용자 추가하기(근본적인 해결방법)

  ```bash
  sudo usermod -aG docker $USER
  ```

  위 명령은현재 사용자(edgar)를 docker 그룹에 추가해서 매번 sudo 없이도 Docker를 쓸 수 있게 해줘.

  **추가 후에는 꼭 로그아웃 후 다시 로그인하거나 셸 재시작이 필요함**

  ```bash
  newgrp docker    # 또는 그냥 재로그인
  ```

### Docker without login

- 로그인 없이 도커 명령어 사용이 가능한 이유
- Docker Hub에 로그인하지 않았어도 public 이미지만 사용할 경우에는 로그인 없이도 실행 가능하다.
- 그 이유는
  - Docker는 설치하면 **로컬에 Docker 엔진(데몬)**이 함께 설치됨
  - docker-compose는 그 엔진에 명령을 보내서 컨테이너를 실행하는 것
  - 로그인은 **Docker Hub(=이미지 저장소)**에서 **private 이미지**를 가져올 때만 필요함

### Unaccessable via brower

- 맥북에서 라즈베리파이에서 실행중인 서버에 접속하려고 시도했으나 간헐적으로 접속되고 접속이 안됨.

- 현재까지 시도

  | 항목                                        | 상태                                    |
  | ------------------------------------------- | --------------------------------------- |
  | 라즈베리파이에서 `curl localhost:3000`      | HTML 응답 정상                          |
  | 라즈베리파이에서 컨테이너 상태(`docker ps`) | blog_web 컨테이너 정상 실행             |
  | 맥북에서 라즈베리파이 IP 3000포트로 접속    | "사이트에 연결할 수 없음"에러           |
  | 같은 공유기 사용                            | 맥북과 라즈베리파이 모두 같은 SSID 연결 |

- 예상할 수 있는 문제는 네트워크 경로 또는 라우팅/방화벽 문제


### Chrome HSTS

- 공유기 관리자 사이트에 접속하고자 했는데 크롬에서만 접속이 불가함

- Safari, 스마트폰에서는 잘 됨 → 네트워크 이상 없음

- Chrome이 HSTS 때문에 https://192.168.35.1로 강제 시도 → 공유기 응답 X → “응답 없음”처럼 보임

- 원인 : 브라우저 캐시, HTTPS 리디렉션, 혹은 세션 정보 때문

  - **HTTPS 자동 리디렉션**

    이전에 IP주소로 잘못 접속 시도했던 기록이 남아서 계속 HTTPS로 가려 함

  - **HSTS 기록**

    크롬은 HSTS(강제 HTTPS 접속 기록)를 캐시에 저장함. 한 번이라도 HTTPS 실패하면 그 주소로는 계속 실패

  - **쿠키/세션 꼬임**

    공유기 로그인 세션이 꼬이거나 남아 있는 쿠키로 접근이 막힐 수 있음

- 해결법 : 크롬에서 해당 주소의 HTTPS 기록 지우기(HSTS 초기화)
  - chrome://net-internals/#hsts 에 접속
    1. Delete domain security policies 아래에IP주소 입력
    2. “Delete” 버튼 클릭
    3. 크롬 완전히 껐다가 다시 실행
    4. 다시 IP주소로 접속 시도

### Port forwarding

- 포트 포워딩 설정을 했으나 외부 접속이 되지 않음

  라즈베리파이에서 블로그가 제대로 실행중인 상태고, 포트 포워딩 설정도 알맞게 했지만 외부에서 접속이 불가능함

- 공유기가 외부에서의 포트 접근을 막고있을 가능성이 존재

  [포트 오픈 테스트 사이트](https://www.yougetsignal.com/tools/open-ports/)에서 "Port to Check"에 설정한 포트번호인 3000, "Remote Address"에 공인 IP주소 입력 후 확인해보니 Port is Closed(공유기에서 막고 있거나 ISP에서 차단 중)가 확인됨

  => 외부에서 라즈베리파이로의 연결이 차단되고 있다는 뜻. 이 경우 SKB에서 외부 포트 자체를 막고 있을 가능성이 높음

- SK 브로드밴드 고객센터(106)에 전화해서

  > *“공인 IP 환경에서 외부 접속 테스트를 하려는데, 공유기의 외부 포트 3000 접근이 막혀 있는 것 같습니다. 포트포워딩이 제대로 되도록 외부 접속 차단을 해제해 주세요.”*

  라고 요청하면 됨.

- 하지만 위에는 그냥 삽질이었고, 관리자 페이지에서 **포트포워딩 "활성화 체크"가 안되어 있어서** 지금까지 안 된 거였음...

### Reverse Proxy

- 가비아에 공유 IP 연결을 한 후에 접속을 해보려고 했지만 접속실패. 다만 ping은 성공함

- 이 경우 대부분 Nginx 프록시로 80포트 연결 필요

- 잘 이해가 안가는 건 공유기 관리자 페이지에서 외부포트는 80 내부포트는 3000으로 설정을 했는데 그렇다면 80포트로 요청이 들어오면 localhost:3000으로 가야하는거 아닌가하는 의문임

- 핵심포인트 :star2:

  공유기 포트포워딩은 "외부 → 라즈베리파이"로 트래픽을 전달해주는 역할만 한다. 하지만 라즈베리파이 내부에서 그 요청을 실제로 받아줄 프로그램(예: Nginx 등)이 없으면 응답은 나오지 않는다.

- 예시 설정 상황

  - 공유기 포트포워딩 : 외부 80 → 내부 192.168.0.101:3000

  - 도커 컨테이너 안에서 Next.js 서버는 3000번 포트에서 실행 중

  - 라즈베리파이의 3000번 포트로 들어오는 요청은 Docker가 잘 받음

  - 하지만 80 포트에는 아무것도 없음

  - 중요한 구분

    | **구간**                  | **역할**          | **설명**                               |
    | ------------------------- | ----------------- | -------------------------------------- |
    | **공유기 → 라즈베리파이** | 포트포워딩        | 외부 포트(80) → 내부 포트(3000)로 전달 |
    | **라즈베리파이 내부**     | 웹 서버(Nginx 등) | 80포트 요청을 실제로 처리해야 함       |

- 여기서 왜 동작을 하지 않는가?

  - 공유기는 분명히 **“80번 포트 요청이 오면 → 라즈베리파이의 3000번 포트로 보내줄게!”** 라고 약속했음.

  - 그런데 라즈베리 파이에 도착한 요청은

    - 목적지 : 3000포트
    - 컨테이너 안의 Next.js 서버는 잘 듣고 있음
    - 하지만 브라우저는 80포트 요청을 함

  - 문제는 

  - 브라우저는 edgar-kim.com:80으로 요청했는데,

    응답을 받는 쪽에서는 **“80 포트에서 받은 요청이 아니니까”**

    → **Host 헤더, 라우팅, 리디렉션 등에서 오작동이 생길 수 있음**

  - 그리고 더 중요한 것은 **라우터가 “포트포워딩”만 해줄 뿐, 라즈베리파이에서 그걸 처리할 서버는 직접 띄워야 한다.**

- 즉, **“공유기에서 포워딩했다 = 자동으로 3000 포트를 받아준다”** 는 게 아님.

- Nginx가 필요한 이유

  - **브라우저**: edgar-kim.com에 접속 → 기본적으로 80포트로 요청 보냄

  - **공유기**: “오케이~ 80포트 왔으니까 192.168.0.101:3000으로 보내줄게”

  - **라즈베리파이**: 

    3000포트: Next.js 컨테이너가 받음 → OK

    **80포트**: ✖ 아무도 안 받고 있음 → 브라우저엔 응답이 없음

  → **Nginx를 80포트에 띄워서 요청을 받아주고**, 내부의 3000포트로 연결해주는 “중계자 역할”이 필요

- 정리
  - 공유기: **배달만 해줌 (80 → 3000)**
  - 라즈베리파이: **문 열어주는 사람 없음** → Nginx가 그 문지기 역할을 해야 함



공유기 포트포워딩은 외부에서 라즈베리파이로 트래픽을 전달해주는 역할만 한다고했는데 트래픽을 전달만 해준다는게 무슨말이야?

그렇다면 라즈베리파이에서 내부포트도 80으로하면 문제가 해결되는 건가?

Nginx말고 이런 요청을 받아줄 프로그램 다른건뭐가있어?

이후에 라즈베리파이가 만약 꺼지게 되면 도커에 올라가있는 서버는 어떻게 되는거야?

### HTTPS Setting

- `curl http://edgar-kim.com/.well-known/acme-challenge/test-file`에서 Next.js 404가 나오는 상황

- 응답이 Next.js에서 온다는 건 Nginx 설정에서 `.well-known/...` 요청을 Next.js로 프록시해버리고 있다는 의미

- 설정은 제대로 되어있는데 Nginx가 이 설정을 적용하고 있지 않음

- `curl http://localhost/.well-known/acme-challenge/test-file` 은 200 OK 그러나`curl http://edgar-kim.com/.well-known/acme-challenge/test-file`는 Next.js 404

  => Nginx 설정은 적용됐고, 로컬에서는 동작함. 하지만 도메인을 타고 들어오는 요청은 Next.js로 프록시됨

  => location 블록 매칭이 실패하고 있음. 즉, `.well-known/...` 요청이 프로시 블록으로 넘어가고 있음

- 도메인 혹은 네트워크 경로 문제

- 문제 가능성 : NAT 제한이 있는 공유기 환경

  NAT Loopback(Hairpin NAT) 제한이 있는 공유기 환경일 수 있다. 즉, 같은 내부망에 있는 맥북에서 공인 IP(도메인)을 통해 접속할 수 없도록 차단되고 있는 상태라는 것.

- 공유기를 껏다가 켜니까 되네...?

  1. **포트포워딩 설정은 저장했지만 내부적으로 적용이 안 되어 있었던 경우**

  2. NAT 테이블이 꼬였거나, Loopback 관련 문제가 메모리에 남아 있었던 경우

  3. 공유기 내 웹 설정 UI에서 저장한 값이 실제 적용 레벨까지 안 간 경우

echo "hello nginx" | sudo tee /var/www/html/.well-known/acme-challenge/test-file