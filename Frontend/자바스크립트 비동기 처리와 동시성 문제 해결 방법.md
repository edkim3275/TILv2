# 자바스크립트 비동기 처리와 동시성 문제 해결 방법

## 자바스크립트 비동기 처리와 동시성 문제 해결 방법

- 자바스크립트는 싱글 스레드 언어이기에 비동기 처리를 통해 효율적으로 작업을 수행할 수 있다.
- 비동기 처리는 주로 콜백 함수, 프로미스, async/await를 통해 이루어진다.
- 비동기 처리를 통해 코드의 가독성을 높이고, 비동기 작업을 순차적으로 처리할 수 있게 해준다.
- 하지만 비동기 작업이 많아질 수록 동시성 문제가 발생할 가능성이 높아진다.
- 여러 비동기 작업이 동시에 실행되면서 예상치 못한 결과를 초래할 수 있다.(Race condition)
- 이를 해결하기 위해서는 **비동기 작업의 순서를 제어**하거나, **공유 자원에 대한 접근을 조절**해야 한다.
- 비동기 처리 방식과 동시성 문제를 해결하는 다양한 방법에 대해서 알아보자.

## 자바스크립트의 비동기 처리 방식

- 자바스크립트에서 비동기 처리는 주로 콜백 함수, 프로미스, async/await를 통해 이루어진다.
- 콜백 함수는 비동기 작업이 완료된 후 호출되는 함수로, 비동기 작업의 결과를 처리하는 데 사용된다.
- 하지만 콜백 함수는 중첩이 많아질수록 코드가 복잡해지고 가독성이 떨어지는 단점이 있다.(Callback Hell)
- 프로미스는 콜백 함수의 단점을 보완하기 위해 등장한 비동기 처리 방식이다.
- 프로미스는 비동기 작업의 성공 또는 실패 상태를 나타내는 객체로, `then()`과 `catch()` 메서드를 통해 비동기 작업의 결과를 처리할 수 있다.
- 하지만 프로미스 또한 `then` 핸들러 함수의 남용으로 인한 Promise Hell이 존재한다.
- async/await는 프로미스를 더욱 간편하게 사용할 수 있게 해주는 문법이다.(Syntatic Sugar)
- async 키워드를 함수 앞에 붙이면 해당 함수는 항상 프로미스를 반환하게 되며, await 키워드를 사용하면 프로미스가 해결될 때까지 기다린 후 결과를 반환한다.
- async/await를 사용하면 비동기 코드를 동기 코드처럼 작성할 수 있어서 가독성이 크게 향상된다.

## 동시성 문제와 레이스 컨디션

- 동시성 문제는 여러 비동기 작업이 동시에 실행되면서 발생하는 문제로써, 주로 레이스 컨디션으로 나타난다.

- 레이스 컨디션은 두 개 이상의 비동기 작업이 동시에 실행되면서 예상치 못한 결과를 초래하는 상황을 말한다.

- 이는 주로 공유 자원에 대한 접근이 제대로 제어되지 않을 때 발생한다.

  예를 들어, 두 개의 비동기 작업이 동시에 같은 공유 변수를 수정하려고 할 때, 예상치 못한 결과가 발생할 수 있다.

## 동시성 문제 해결 방법

- 동시성 문제를 해결하기 위해서는 비동기 작업의 순서를 제어하거나, 공유 자원에 대한 접근을 조절해야 한다.

- 첫 번째 방법은 async/await를 사용하여 비동기 작업을 순차적으로 실행하는 것. 이렇게 하면 비동기 작업이 순서대로 실행되므로 동시성 문제가 발생하지 않는다.

- 두 번째 방법은 뮤텍스(Mutux)와 같은 동기화 메커니즘을 사용하는 것. 뮤텍스는 하나의 작업이 완료될 때까지 다른 작업이 해당 자원에 접근하지 못하도록 막아준다. 즉, 여러 프로세스나 스레드가 동시에 공유 자원에 접근하는 문제를 방지하기 위해 사용된다.

  이를 통해 공유 자원에 대한 접근을 제어할 수 있다.

  >:balloon: 뮤텍스(Mutex)는 상호 배제(Mutual Excluion)의 약자로, 여러 프로세스나 스레드가 동시에 공유 자원(Shared Resource)에 접근하는 것을 막기 위해 사용되는 동기화 기법이다. 스레드가 뮤텍스를 잠그면, 다른 스레드는 해당 뮤텍스를 사용할 수 없다. 작업이 끝나면 뮤텍스를 해제하여 다른 대기 중인 작업이 자원에 접근할 수 있도록 한다.

- 세 번째 방법은 비동기 작업을 큐에 넣고 순차적으로 처리하는 것. 이렇게 하면 비동기 작업이 순서대로 실행되므로 동시성 문제가 발생하지 않는다. 

- 뮤텍스(Mutex) 예제

  뮤텍스를 사용하면 하나의 작업이 완료될 때까지 다른 작업 해당 자원에 접근하지 못하도록 막아줄 수 있다.

  ```js
  class Mutex {
    constructor() {
      this.queue = []; // 잠금을 기다리는 작업을 저장하는 큐
      this.locked = false; // 현재 뮤텍스가 잠긴 상태인지 여부
    }
    
    lock() {
      return new Promise(resolve => {
        if (this.locked) {
          this.queue.push(resolve);
        } else {
          this.locked = true;
          resolve();
        }
      });
    }
    
    unlock() {
      if (this.queue.length > 0) {
        const resolve = this.queue.shift();
        resolve();
      } else {
        this.locked = false;
      }
    }
  }
  
  const mutex = new Mutex();
  
  async function criticalSection() {
    await mutex.lock();
    // 공유 자원에 접근
    mutex.unlock();
  }
  ```

  여러 비동기 함수가 `criticalSection`을 호출한다고 가정합니다.

  1. 첫 번째 함수가 `mutex.lock()`을 호출:
     - `locked`는 `false`이므로 바로 잠금을 설정하고, 공유 자원에 접근합니다.
  2. 두 번째 함수가 `mutex.lock()`을 호출:
     - `locked`가 이미 `true`이므로 `resolve`를 큐에 저장하고 대기합니다.
  3. 첫 번째 함수가 작업을 끝내고 `mutex.unlock()`을 호출:
     - `queue`에 대기 중인 작업이 있으므로 큐에서 첫 번째 작업을 꺼내 실행합니다.
  4. 두 번째 함수가 작업을 수행한 뒤 `mutex.unlock()`을 호출:
     - 더 이상 대기 중인 작업이 없으므로 `locked`를 `false`로 설정하여 뮤텍스를 해제합니다.

## React Query에서의 동시성 문제 해결

- React에서는 여러 컴포넌트가 동일한 상태를 비동기로 업데이트하면서 충돌이 발생할 가능성이 존재.

- React Query는 API 호출과 비동기 작업 관리를 간편하고 직관적으로 처리할 수 있도록 도와주는 라이브러리

- 특히 캐싱, 상태 관리, 데이터 동기화, 재요청 제어와 같은 기능을 제공하여 개발자가 직접 비동기 작업의 동기화 문제를 해결하지 않아도 되게 해준다.

  이를 통해 뮤텍스를 사용하는 것보다 더 간편하게 동시성 문제를 해결할 수 있다.

- React Query는 API 요청의 결과를 자동으로 캐싱한다. 동일한 요청이 발생하면 캐시 데이터를 즉시 반환하고, 필요할 때만 네트워크 요청을 보내기 때문에 불필요한 API 호출을 방지한다.

  동일한 데이터를 여러 번 요청할 필요가 없으므로 중복 요청이 일어나지 않는다.

  ```react
  import { useQuery } from 'react-query';
  
  function MyComponent() {
    const { data, loading, error } = useQuery('userData', () => {
      fetch('/api/user').then(res => res.json())
    })
    
    if (isLoading) return <p>Loading...</p>;
    if (error) return <p>Error occurred!</p>;
  
    return <div>{data.name}</div>;
  }
  ```

- 동일한 키를 가진 요청이 이미 진행 중이면 React Query는 새로운 요청을 보내지 않고 기존 요청이 끝날 때까지 대기합니다. 즉, 여러 컴포넌트에서 동일한 키 사용 시 하나의 요청만 전송된다. 따라서 중복 API 요청 문제가 해결된다.

## 비동기 처리와 동시성 문제 해결의 중요성

- 비동기 처리와 동시성 문제 해결은 자바스크립트 개발에서 매우 중요한 주제임.
- 비동기 처리를 통해 효율적으로 작업을 수행할 수 있지만, 동시성 문제가 발생할 수 있기 때문에 이를 해결하는 방법을 잘 알고 있어야 한다.(async/await, 동기화 메커니즘, 큐를 활용한 비동기 작업의 순차적 처리)
- 동시성 문제를 해결하기 위해서는 비동기 작업의 순서를 제어하거나, 공유 자원에 대한 접근을 조절해야 한다.
- 자바스크립트에서는 async/await, 뮤텍스(Mutex), 큐와 같은 다양한 방법을 통해 동시성 문제를 해결할 수 있다.

## 참고

[자바스크립트 비동기 처리와 동시성 문제 해결 방법](https://f-lab.kr/insight/javascript-async-concurrency-20240626)