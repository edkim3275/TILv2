# JWT

## 무상태(stateless) 🤨

HTTP 프로토콜은 기본적으로 **상태를 유지하지 않는(stateless) 프로토콜**이기 때문에, 연결이 해제됨과 동시에 서버와 클라이언트는 클라이언트가 이전에 요청한 결과에 대해 잊어버리게 됨. 즉, 요청을 할 때마다 서버에 연결을 해야한다는 것.

따라서 웹 애플리케이션에서는 효율적인 서버-클라 연결을 위해 웹 애플리케이션에서 사용자의 상태를 계속 추적하고 유지하기 위한 방식이 필요하게 됨.

결국 "사용자 너 어떻게 인증할래?"에 대한 여러가지 해결방식인 것. 서버에서 사용자 인증을 위한 정보를 실어서 클라이언트에게 보내고, 해당 정보를 통신에 사용하는 것.

## JWT?

JSON Web Token의 약자로, 정보를 안전하게 전송하기 위한 일종의 토큰 형식. 주로 웹 통신에서 사용되고, 특히 인증 및 권한 부여를 위해 자주 활용됨.

> *토큰*
>
> 일반적으로 컴퓨터 시스템에서 사용자나 프로그램이나 서버가 자신의 신원을 증명하거나 특정 자원에 접근하도록 하는 데 사용되는 작은 조각의 정보를 나타냄. JWT는 특정한 목적(정보 교환 및 인증 및 권한 부여)을 위해 JSON 형식으로 설계된 토큰 형식

### JWT 구조

기본적으로 육안으로 해석하기 어려운 문자열로 만들어져 있고, https://jwt.io/ 에서 해독(decode)하면 JSON형태로 들어있는 정보를 확인할 수 있다.

![image-20231203162838328](/Users/edgar/Documents/TILv2/Frontend/JWT.assets/image-20231203162838328.png)

<img src="/Users/edgar/Documents/TILv2/Frontend/JWT.assets/image-20231203163034970.png" alt="image-20231203163034970" style="zoom: 33%;" />

```
header.payload.signature
xxxxxxxxxx.yyyyyyyyyy.zzzzzzzzzz
```

1. Header(헤더)

   JWT의 유형 및 해시 알고리즘과 같은 메타데이터 정보 포함. `HS256(HMAC SHA-256)`알고리즘은 주로 사용되는 대표적인 대칭키 알고리즘 중 하나로써 서버와 클라이언트 간에 공유된 시크릿 키를 사용하여 서명하고 생성하고 검증함.

   ```json
   {
     "alg": "HS256",
     "typ": "JWT"
   }
   ```

2. Payload(페이로드)

   토큰에 담길 정보를 표현하는 부분. 클레임(claim)이라고 불리는 키-값 쌍들의 집합.

   ```json
   {
     "name": "username",
     "sub": "1294392",
   }
   ```

3. Signature(서명)

   토큰이 변조되지 않았음을 검증하기 위한 서명. 헤더, 페이로드, 비밀키를 이용하여 생성되고 서명이 유효한지 확인하여 토큰의 무결성을 보장함.

   ```json
   HMACSHA256(
   	base64UrlEncode(header) + "." + base65UrlEncode(payload),
     secretKey
   )
   ```

   서명검증 과정

   1. Base64 디코딩 : Base64로 인코딩 되어있는 JWT의 Header와 Payload를 디코딩하여 원본 JSON 데이터를 얻는다.
   2. 서명생성 : 디코딩된 Header와 Payload를 합쳐 문자열을 구성하고, 이를 지정된 알고리즘(Header의 `alg`필드에 명시된 알고리즘)을 사용하여 서명
   3. 서명 검증 : 생성된 서명과 JWT에 포함된 서명을 비교하여 두 값이 일치하는지 확인.

### JWT의 특징

- 정보를 안전하게 전송하고, 서버와 클라간에 상태를 유지하지 않고(statelessness)도 사용자를 식별하고 권한을 부여할 수 있게 해준다.
- 세션을 유지하지 않고도 상태를 관리할 수 있는 무상태성의 특성을 제공
- 사용자 인증 후 서버는 JWT를 생성하여 클라이언트에게 전달하고, 클라이언트는 이를 이용하여 서버에 대한 요청을 할 수 있음.
- **인증 정보를 서버쪽에 저장하지 않는다**는 점. 클라이언트가 JWT를 사용하여 자신의 상태를 유지하게되므로, 서버는 무상태한 아키텍처를 유지할 수 있다.

### 클라-서버 통신과정

![image-20231203163237495](/Users/edgar/Documents/TILv2/Frontend/JWT.assets/image-20231203163237495.png)

1. 로그인(클라이언트에서 서버로 요청)

   클라이언트는 아이디와 패스워드와 같은 인증정보를 서버로 전송하여 로그인 요청.

2. JWT생성(서버에서 클라이언트로 응답)

   서버는 클라이언트의 인증 정보(아이디, 패스워드 등)를 확인하고 로그인 정보가 올바르면 클라이언트에 대한 정보를 포함한 JSON 형식으로 된 토큰인 JWT를 생성.

   JWT에는 클라이언트에 대한 정보, 권한, 만료 기간등이 포함된다. **단, 이 토큰이 클라이언트에게 보내지기 때문에 탈취 당할 위험이 있으므로 중요 정보는 포함시키지 않는다.**

3. 발급한 JWT 전송

   서버는 생성된 JWT를 클라이언트에게 안전한 방식으로 전송. 주로 HTTP 응답 헤더의 `Set-Cookie` 로 전송

4. 클라이언트에서 서버로 보안된 요청 전송

   클라이언트는 토큰을 어딘가에 저장(세션스토리지, 로컬스토리지, 쿠키 등)하고 요청을 보낼 때 생성된 JWT를 포함하여 서버에 전송. 주로 HTTP 요청 헤더의 `Authorization`에 `Bearer` 스키마를 사용하여 전송.

   ```javascript
   // 쿠키에 저장했을 경우
   const jwtToken = document.cookie.split('; ').find(cookie => cookie.startsWith('jwt='));
   const jwtToken = jwtTokenFromCookie ? jwtTokenFromCookie.split('=')[1] : null;
   // 로컬스토리지에 저장했을 경우
   const jwtToken = localStorage.getItem('jwtToken');
   // 세션스토리지에 저장했을 경우
   const jwtToken = sessionStorage.getItem('getToken')
   fetch(url, {
     method: 'GET',
     headers: {
       'Authorization': `Bearer ${jwtToken}`
     }
   })
   ```

5. JWT 검증(서버에서 클라이언트의 요청 처리)

   서버는 클라이언트로부터 전송된 JWT를 받고, JWT의 서명을 검증하고 만료 여부를 확인한다. 유효한 경우 JWT에 포함된 클라이언트 정보를 사용하여 요청을 처리

6. 응답

   요청 작업에 대해 응답하고 통신 종료.

### 장점과 단점

- 장점

  - OAuth를 사용 시 여러 소셜 사이트에서 사용가능
  - 서버측 부하를 낮출 수 있고, 독립적으로 접근 권한을 관리할 수 있음
  - 별로의 인증 저장소가 필요하지 않아서 인증서버와 DB에 의존하지 않아도 됨.

- 단점

  - 쿠키, 로컬스토리지, 세션스토리지에 저장되므로 탈취당할 위험이 존재. 따라서 중요 정보를 넣지 말아야 함.

  - 토큰 내에 들어가는 데이터가 많아질수록 토큰이 길어지는데 매 API 호출 시마다 토큰 데이터를 서버에 전달하게 되므로 그만큼 네트워크 대역폭 낭비가 심할 수 있음

  - 한번 발급된 token은 수정, 폐기가 불가

    보안점1) Access token의 Expire time을 짧게 하고, Refresh token을 이용해서 중간중간 Access token을 재발급하게 해서 Access token이 탈취되더라도 공격자가 이용할 수 있는 시간을 최소화 하는 것.

## 세션

- 방문자가 웹서버에 접속해 있는 상태를 하나의 단위로 보고 그것을 session이라고 한다. 

  웹 서버는 이러한 각 단위에 대한 세션 식별자(sessionID)를 부여하고 같은 브라우저인지 구별한다.

  브라우저를 닫거나 서버에서 해당 세션 식별자가 있는 쿠키를 삭제했을때 삭제된다.

- 세션(Session)

  HTTP 프로토콜은 기본적으로 **상태를 유지하지 않는(stateless) 프로토콜**이기 때문에, 웹 애플리케이션에서 사용자의 상태를 계속 추적하고 유지하기 위해 세션을 사용.

  세션이란 웹 애플리케이션에서 사용자의 상태를 유지하고 관리하기 위한 매커니즘을 말함.

  세션을 유지한다는 것은 특정 사용자에 대한 정보를 서버 측에 저장하고, 이 정보를 세션을 통해 지속적으로 유지하는 것을 의미.

### 세션 유지 절차(session flow)

![image-20231203161501430](/Users/edgar/Documents/TILv2/Frontend/JWT.assets/image-20231203161501430.png)

1. 로그인

   사용자 로그인 시 클라이언트가 서버에게 로그인 정보가 들어있는 파라미터와 함께 로그인 요청.

2. 세션 식별자 부여

   클라이언트로 부터 받은 로그인 정보가 올바르면 세션 객체를 생성하여 해당 사용자에 대한 정보(ID, 권한 등)를 세션에 저장, 세션 정보를 유지하기 위해 서버는 클라이언트에게 고유한 세션 식별자를 할당하고, 이를 `Set-cookie`를 통해 클라이언트에게 전달. 일반적으로 쿠키를 사용하여 세션 식별자를 클라이언트에게 부여. 

   세션 객체는 서버에 저장해놓는다.

3. 요청과 응답 시 세션 활용

   클라이언트가 서버에 요청을 보낼 때, 요청 헤더에 세션 식별자가 함께 전송.

   서버는 해당 세션 식별자를 통해 어떤 사용자에 대한 요청인지 인식(세션 객체를 검색). 서버는 세션에 저장된 정보를 이용하여 정보가 있으면 사용자 상태를 확인하고 요청을 처리

4. 로그아웃 혹은 세션 만료

   사용자가 로그아웃하거나 세션이 일정 기간 유지되지 않으면 세션 정보는 삭제되거나 만료됨.

### 장점과 단점

- 장점

  - 쿠키방식과 동일하지만 쿠키에 아무런 의미가 없는 sessionID가 저장되므로 탈취되더라도 해석할 수 없다.

- 단점

  - 하이재킹 공격으로 중간에 공격자가 쿠키를 탈취하여 HTTP 요청을 보낼 수 있는 위험성

    보안점1) HTTPS를 사용하여 요청 자체를 탈취해도 내부 정보 보안성 향상

    보안점2) 세션에 유효시간을 넣어 유효시간이 끝나면 더 이상 이용할 수 없게 설정

  - 서버에 세션 객체를 저장하므로 사용자가 다수일 경우 서버 부하가 높아진다는 점

  - 확장시 모든 서버가 접근할 수 있도록 별도 중앙 세션 관리 시스템이 필요

  - CORS

## 쿠키

쿠키(Cookie)는 **클라이언트 측에 저장되는 키-값 쌍으로 이루어진 작은 데이터 조각**을 의미한다.  즉 세션 식별자를 쿠키로 저장한다는 것은 해당 세션 식별자 값을 쿠키 형태로 클라이언트에 저장하는 것을 의미한다.

브라우저는 쿠키를 요청 헤더에 포함하여 서버에 요청을 보내므로, 개발자는 주로 이러한 과정을 명시적으로 다루지는 않는다. 즉, 서버로 요청을 보낼 때 브라우저는 해당 도메인에 저장된 모든 쿠키를 요청 헤더에 자동으로 포함시키게 됨.

```javascript
fetch('/login', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    username: 'name',
    password: 'pw'
  })
})
	.then(res => res.json())
	.then(data => {
  	// 1. 서버 응답에 Set-Cookie헤더가 있다면, 브라우저가 해당 쿠키를 저장함
  	// 2. 이후 다른 요청에서는 브라우저가 자동적으로 쿠키를 요청 헤더에 포함시킴
  	fetch('/otherEndpoint', {
      method: 'GET'
    })
  		.then(response => response.json())
  		.then(data => console.log(data))
	})
```

쿠키에는 다양한 설정 옵션이 존재한다.

```
Set-Cookie: session_id=abcdef123456; Path=/; Expires=Wed, 01 Jan 2023 00:00:00 GMT; Secure; HttpOnly
```

`session_id`라는 쿠키를 설정하고, 해당 쿠키는 `/` 경로에서만 유효하고, 23년 1월 1일까지만 유효하고, 안전한 연결(HTTPS)에서만 전송되고, JavaScript에서 접근할 수 없도록 설정.

`Path` : 쿠키가 유효한 경로를 지정. 예를들어 `Path=/admin`이라고 설정하면 해당 경로에서만 쿠키가 유효하게 됨.

`Expires` or `Max-Age` : 쿠키의 유효 기간을 설정. 만료시간이 지나면 브라우저는 해당 쿠키를 삭제

`Domain` : 쿠키의 유효한 도메인 지정. 도메인이 지정되면 해당 도메인 및 서브도메인에서 쿠키가 유효.

`Secure` : 쿠키를 안전한 연결(HTTPS)에서만 전송하도록 지정

`HttpOnly` : JavaScript에서 쿠키에 접근하는 것을 방지하고, 보안을 강화

위와같은 쿠키를 백엔드(express.js)에서 설정하여 응답을 보내는 예시 코드는 아래와 같이 될 수 있다.

```javascript
// 로그인 성공 시 클라이언트에게 세션 식별자를 쿠키로 설정하는 예제
const express = require('express');
const crypto = require('crypto');
const app = express();

const generateSessionId = (length) => {
  return crypto.randomBytes(length).toString('hex');
}
app.post('/login', (req, res) => {
  // 길이가 16인 랜덤한 세션 식별자 생성
  const sessionID = generateSessionId(16);
  
  const expirationDate = new Date();
  // expirationDate 일 년으로 설정
	// expirationDate.setFullYear(expirationDate.getFullYear()+1);
  // expirationDate 하루로 설정
  expirationDate.setHours(expirationDate.getHours() + 24);
  
  res.cookie('session_id', sessionID, {
    path: '/', // 모든 경로에서 유효(path는 하나의 경로만 지정 가능하고 해당 경로의 하위 모든 경로에서 유효하게 됨)
    expires: expirationDate,
    secure: true,
    httpOnly: true,
  })
  
  res.send('Login successful')
})
```

## 로컬 스토리지 vs. 세션 스토리지 vs. 세션 vs. 쿠키

모두 웹 애플리케이션에서 상태를 유지하고 사용자 식별을 위해 사용되는 매커니즘이라고 볼 수 있다.

- 세션(Session)

  - 용도 : 주로 **서버에서 상태를 유지**하고 **사용자 식별, 권한 부여 정보** 등을 저장하는 데 사용

  - 저장 위치 : 주로 서버 측에 저장. 서버 메모리, 데이터베이스 등을 통해 세션 데이터가 관리된다.

  - 전송 : 세션 식별자는 클라이언트에게 전송되어 서버와의 상호 작용에 사용되지만, 실제 세션 데이터는 서버에 저장되어 있음

- 쿠키(Cookie)

  - 용도 : 주로 HTTP 요청과 응답 사이에 클라이언트에서 상태 정보를 유지하고, 사용자가 브라우저를 닫아도 정보를 보존하기 위해 사용. 로그인 상태, 사용자 선호 설정, 트래킹 등을 저장
  - 저장 기간 : 만료 기간을 설정할 수 있고, 만료 기간이 지나면 자동으로 삭제됨.
  - 저장 위치 : 클라이언트 측에 저장. 브라우저의 쿠키 저장소에 보관
  - 전송 : HTTP 요청과 함께 자동으로 서버에 전송

- 로컬 스토리지(Local Storage)

  - 용도 : 클라이언트 측에서 데이터를 지속적으로 저장하고 유지하기 위해 사용
  - 저장 기간 : 브라우저를 닫아도 데이터가 지속된다.
  - 전송 : 자동으로 HTTP 요청에 포함되지 않는다. 클라이언트 측에서만 사용되는 저장소

- 세션 스토리지(Session Storage)

  - 세션(브라우저를 닫을 때 까지의 시간) 동안 데이터를 지속적으로 저장하고 유지하기 위해 사용
  - 저장 기간 : 브라우저를 닫으면 데이터가 삭제됨
  - 전송 : 자동으로 HTTP 요청에 포함되지 않는다. 클라이언트 측에서만 사용되는 저장소

- 세션 식별자를 쿠키에 저장하는 이유

  일반적으로 사용성과 효율성을 향상시키기 위해 선택됨.

  1. 무상태성의 원칙

     웹의 기본 아키텍처는 무상태성. 서버는 각 요청을 독립적으로 처리하고, 이전 요청의 상태를 기억하지 않는다. 하지만 세션 식별자를 쿠키에 저장하면 클라이언트가 서버와의 상태를 유지할 수 있어, 서버는 각 요청을 독립적으로 처리하는 것이 가능해진다.

  2. 간편성 및 편의성

     쿠키는 브라우저에서 자동으로 관리되고, 서버 및 클라이언트 간의 편리한 데이터 전송을 제공. 세션 식별자를 쿠키에 저장하면 클라이언트는 별도의 작업 없이 세션을 관리할 수 있게됨

  3. 다양한 저장소 지원

     쿠키는 브라우저의 쿠키 저장소뿐만 아니라, 로컬 스토리지, 세션 스토리지, 인덱 DB등 다양한 클라이언트 측 저장소에 저장될 수 있음.

  4. 다중 탭 및 창에서의 공유

     쿠키는 여러 탭이나 창 간에 공유되므로, 하나의 브라우저 창에서 로그인한 상태에서 다른 창도 로그인 상태를 공유할 수 있음.

  5. 서버 리소스 감소

     서버에 세션 상태를 저장하는 것은 메모리 또는 데이터베이스 자원을 사용하게 됨. 따라서 쿠키에 세션 식별자를 저장하면 클라이언트 측에서 상태를 유지하므로 서버 리소스 사용을 줄일 수 있음.